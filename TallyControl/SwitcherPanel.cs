/* -LICENSE-START-
** Copyright (c) 2011 Blackmagic Design
**
** Permission is hereby granted, free of charge, to any person or organization
** obtaining a copy of the software and accompanying documentation covered by
** this license (the "Software") to use, reproduce, display, distribute,
** execute, and transmit the Software, and to prepare derivative works of the
** Software, and to permit third-parties to whom the Software is furnished to
** do so, all subject to the following:
** 
** The copyright notices in the Software and this entire statement, including
** the above license grant, this restriction and the following disclaimer,
** must be included in all copies of the Software, in whole or in part, and
** all derivative works of the Software, unless such copies or derivative
** works are solely in the form of machine-executable object code generated by
** a source language processor.
** 
** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
** IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
** FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
** SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
** FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
** ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
** DEALINGS IN THE SOFTWARE.
** -LICENSE-END-
*/

using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Windows.Forms;

using System.Runtime.InteropServices;

using BMDSwitcherAPI;

namespace SwitcherPanelCSharp
{
    public partial class TallyControl : Form
    {
        private IBMDSwitcherDiscovery m_switcherDiscovery;
        private IBMDSwitcher m_switcher;
        private IBMDSwitcherMixEffectBlock m_mixEffectBlock1;

        private SwitcherMonitor m_switcherMonitor;
        private MixEffectBlockMonitor m_mixEffectBlockMonitor;

        private List<InputMonitor> m_inputMonitors = new List<InputMonitor>();

        public TallyControl()
        {
            InitializeComponent();

            m_switcherMonitor = new SwitcherMonitor();
            // note: this invoke pattern ensures our callback is called in the main thread. We are making double
            // use of lambda expressions here to achieve this.
            // Essentially, the events will arrive at the callback class (implemented by our monitor classes)
            // on a separate thread. We must marshell these to the main thread, and we're doing this by calling
            // invoke on the Windows Forms object. The lambda expression is just a simplification.
            m_switcherMonitor.SwitcherDisconnected += new SwitcherEventHandler((s, a) => this.Invoke((Action)(() => SwitcherDisconnected())));

            m_mixEffectBlockMonitor = new MixEffectBlockMonitor();
            m_mixEffectBlockMonitor.ProgramInputChanged += new SwitcherEventHandler((s, a) => this.Invoke((Action)(() => UpdateProgramButtonSelection())));
            m_mixEffectBlockMonitor.TransitionPositionChanged += new SwitcherEventHandler((s, a) => this.Invoke((Action)(() => UpdateProgramButtonSelection())));

            m_switcherDiscovery = new CBMDSwitcherDiscovery();
            if (m_switcherDiscovery == null)
            {
                MessageBox.Show("Could not create Switcher Discovery Instance.\nATEM Switcher Software may not be installed.", "Error");
                Environment.Exit(1);
            }
            
            SwitcherDisconnected();		// start with switcher disconnected

            // Grab a list of serial ports
            cmbPort.Items.Clear();
            foreach (string s in System.IO.Ports.SerialPort.GetPortNames())
            {
                cmbPort.Items.Add(s);
            }

            // Defaults
            cmbTallyChannel1.SelectedIndex = 0;
            cmbTallyChannel2.SelectedIndex = 1;
            cmbTallyChannel3.SelectedIndex = 2;
            cmbTallyChannel4.SelectedIndex = 3;
        }

        private void SwitcherConnected()
        {
            buttonConnect.Enabled = false;

            // Get the switcher name:
            string switcherName;
            m_switcher.GetProductName(out switcherName);
            textBoxSwitcherName.Text = switcherName;

            // Install SwitcherMonitor callbacks:
            m_switcher.AddCallback(m_switcherMonitor);

            // We want to get the first Mix Effect block (ME 1). We create a ME iterator,
            // and then get the first one:
            m_mixEffectBlock1 = null;
            IBMDSwitcherMixEffectBlockIterator meIterator;
            SwitcherAPIHelper.CreateIterator(m_switcher, out meIterator);

            if (meIterator != null)
            {
                meIterator.Next(out m_mixEffectBlock1);
            }

            if (m_mixEffectBlock1 == null)
            {
                MessageBox.Show("Unexpected: Could not get first mix effect block", "Error");
                return;
            }

            // Install MixEffectBlockMonitor callbacks:
            m_mixEffectBlock1.AddCallback(m_mixEffectBlockMonitor);
            UpdateProgramButtonSelection();
        }

        private void SwitcherDisconnected()
        {
            buttonConnect.Enabled = true;
            textBoxSwitcherName.Text = "";

            if (m_mixEffectBlock1 != null)
            {
                // Remove callback
                m_mixEffectBlock1.RemoveCallback(m_mixEffectBlockMonitor);

                // Release reference
                m_mixEffectBlock1 = null;
            }

            if (m_switcher != null)
            {
                // Remove callback:
                m_switcher.RemoveCallback(m_switcherMonitor);

                // release reference:
                m_switcher = null;
            }
        }

        private void UpdateProgramButtonSelection()
        {
            long programId;
            int previewLive;
            long previewId;

            try
            {
                m_mixEffectBlock1.GetInt(_BMDSwitcherMixEffectBlockPropertyId.bmdSwitcherMixEffectBlockPropertyIdProgramInput, out programId);
                m_mixEffectBlock1.GetFlag(_BMDSwitcherMixEffectBlockPropertyId.bmdSwitcherMixEffectBlockPropertyIdPreviewLive, out previewLive);
                if (previewLive > 0)
                {
                    m_mixEffectBlock1.GetInt(_BMDSwitcherMixEffectBlockPropertyId.bmdSwitcherMixEffectBlockPropertyIdPreviewInput, out previewId);
                }
                else
                {
                    previewId = -1;
                }
            }
            catch (Exception)
            {
                return;
            }

            lblLamp1.BackColor = Color.DarkGray;
            lblLamp2.BackColor = Color.DarkGray;
            lblLamp3.BackColor = Color.DarkGray;
            lblLamp4.BackColor = Color.DarkGray;

            // Work out which Tally channel to drive
            int channelno = -1;
            switch (programId)
            {
                case 5:
                    channelno = cmbTallyChannel1.SelectedIndex;
                    lblLamp1.BackColor = Color.Red;
                    break;
                case 6:
                    channelno = cmbTallyChannel2.SelectedIndex;
                    lblLamp2.BackColor = Color.Red;
                    break;
                case 7:
                    channelno = cmbTallyChannel3.SelectedIndex;
                    lblLamp3.BackColor = Color.Red;
                    break;
                case 8:
                    channelno = cmbTallyChannel4.SelectedIndex;
                    lblLamp4.BackColor = Color.Red;
                    break;
                default:
                    break;
            }

            // Bail out if Tally isn't up
            if (!serialTally.IsOpen)
            {
                return;
            }
            
            // Ok, so far, so good. Now turn off everthing already on
            serialTally.WriteLine("<dark>");

            if (-1 == channelno)
            {
                // No Tally channel selected, nothing to do
                return;
            }

            // And drive our chosen line
            serialTally.Write("<dd0" + channelno.ToString() + ">\n");

            // Drive preview?
            if (previewId > -1)
            {
                // Work out which Tally channel to drive
                int prevchannel = 0;
                switch (previewId)
                {
                    case 5:
                        prevchannel = cmbTallyChannel1.SelectedIndex;
                        lblLamp1.BackColor = Color.Red;
                        break;
                    case 6:
                        prevchannel = cmbTallyChannel2.SelectedIndex;
                        lblLamp2.BackColor = Color.Red;
                        break;
                    case 7:
                        prevchannel = cmbTallyChannel3.SelectedIndex;
                        lblLamp3.BackColor = Color.Red;
                        break;
                    case 8:
                        prevchannel = cmbTallyChannel4.SelectedIndex;
                        lblLamp4.BackColor = Color.Red;
                        break;
                    default:
                        MessageBox.Show("Where the hell did that channel " +
                            prevchannel.ToString() + " come from??");
                        break;
                }

                if (-1 == prevchannel)
                {
                    // No Tally channel selected, nothing to do
                    return;
                }

                // And drive our chosen line
                serialTally.Write("<dd0" + prevchannel.ToString() + ">\n");
            }
        }

        private void buttonConnect_Click(object sender, EventArgs e)
        {
            _BMDSwitcherConnectToFailure failReason = 0;
            string address = textBoxIP.Text;

            try
            {
                // Note that ConnectTo() can take several seconds to return, both for success or failure,
                // depending upon hostname resolution and network response times, so it may be best to
                // do this in a separate thread to prevent the main GUI thread blocking.
                m_switcherDiscovery.ConnectTo(address, out m_switcher, out failReason);
            }
            catch (COMException)
            {
                // An exception will be thrown if ConnectTo fails. For more information, see failReason.
                switch (failReason)
                {
                    case _BMDSwitcherConnectToFailure.bmdSwitcherConnectToFailureNoResponse:
                        MessageBox.Show("No response from Switcher", "Error");
                        break;
                    case _BMDSwitcherConnectToFailure.bmdSwitcherConnectToFailureIncompatibleFirmware:
                        MessageBox.Show("Switcher has incompatible firmware", "Error");
                        break;
                    default:
                        MessageBox.Show("Connection failed for unknown reason", "Error");
                        break;
                }
                return;
            }

            SwitcherConnected();
        }


        /// <summary>
        /// Used for putting other object types into combo boxes.
        /// </summary>
        struct StringObjectPair<T>
        {
            public string name;
            public T value;

            public StringObjectPair(string name, T value)
            {
                this.name = name;
                this.value = value;
            }

            public override string ToString()
            {
                return name;
            }
        }

        private void label3_Click(object sender, EventArgs e)
        {

        }

        private void lblLamp1_Click(object sender, EventArgs e)
        {

        }

        private void btnTallyConnect_Click(object sender, EventArgs e)
        {
            serialTally.Close();
            if (null == cmbPort.SelectedItem)
            {
                return;
            }
            serialTally.PortName = (string)cmbPort.SelectedItem;

            try
            {
                serialTally.Open();
                serialTally.WriteLine("<dark>\n");
                UpdateProgramButtonSelection();
                btnTallyConnect.Enabled = false;
            }
            catch (Exception ex)
            {
                MessageBox.Show("Couldn't connect. Error: " + ex.Message);
            }
        }

        private void btnLampTest_Click(object sender, EventArgs e)
        {
            if (!serialTally.IsOpen)
            {
                MessageBox.Show("Tally not up!");
                return;
            }

            serialTally.Write("<dd00>\n");
            serialTally.Write("<dd01>\n");
            serialTally.Write("<dd02>\n");
            serialTally.Write("<dd03>\n");
            serialTally.Write("<dd04>\n");
            serialTally.Write("<dd05>\n");

            MessageBox.Show("Testing lamps");

            serialTally.Write("<dark>\n");

            if (m_mixEffectBlock1 != null)
            {
                UpdateProgramButtonSelection();
            }
        }

        private void cmbTallyChannel1_SelectedIndexChanged(object sender, EventArgs e)
        {
            UpdateProgramButtonSelection();
        }

        private void cmbTallyChannel2_SelectedIndexChanged(object sender, EventArgs e)
        {
            UpdateProgramButtonSelection();
        }

        private void cmbTallyChannel3_SelectedIndexChanged(object sender, EventArgs e)
        {
            UpdateProgramButtonSelection();
        }

        private void cmbTallyChannel4_SelectedIndexChanged(object sender, EventArgs e)
        {
            UpdateProgramButtonSelection();
        }
    }
}
